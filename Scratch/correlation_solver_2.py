import numpy as np
import time
import constants as c
import utilities
import problem_parameters as pp
import matplotlib.pyplot as plt
import numpy.linalg
from scipy.sparse import linalg
import occupation_solver
import preprocessing


class gmres_counter(object):
    """A class object that can be called during GMRES to print stepwise iterative residual."""
    def __init__(self, disp=True):
        self._disp = disp
        self.niter = 0

    def __call__(self, rk=None):
        self.niter += 1
        if self._disp:
            print('iter %3i\trk = %s' % (self.niter, str(rk)))


def correlation_1(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient Gamma vd-vd autocorrelation using the full
    finite difference matrix.
    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    print('Starting transient correlation 1 solver for {:.3E} V/m and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*2*np.pi*freq)  # Positive quantity
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
        print('Not applying correction factor to the scattering matrix.')
    _, _,_, _, matrix_fd  = occupation_solver.apply_centraldiff_matrix(matrix_fd, df, field)
    if pp.derL:
        _,_,_,matrix_fd = occupation_solver.apply_centraldiff_matrix_L(matrix_fd, df, field)
    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    if pp.verboseError:
        b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
        error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
        print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,False)
    g_df = df.loc[g_inds]
    b = np.zeros(len(df))
    g_vel = utilities.mean_velocity(chi[g_inds],g_df)
    b[g_inds] = (-1) * ((g_df['vx [m/s]'] - g_vel) * f[g_inds])
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    print('Calculating preconditioner.')
    diagonal = np.diag(freq_matrix+matrix_sc * scmfac-matrix_fd)
    M = np.diag(np.reciprocal(diagonal))
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence,M=M)

    if pp.verboseError:
        b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
        error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
        print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
        print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
        print('Relative residual error is {:3E}'.format(error))
        print('GMRES convergence criteria: {:3E}'.format(criteria))
    else:
        error = 0
        print('Error not stored.')
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi
    return g_next, g_0,error, counter.niter


def correlation_2(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient vd-vd autocorrelation using the full
    finite difference matrix.
    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    print('Starting transient correlation 2 solver for {:.3E} V/m and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*2*np.pi*freq)  # Positive quantity
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
        print('Not applying correction factor to the scattering matrix.')
    _, _,_, _, matrix_fd  = occupation_solver.apply_centraldiff_matrix(matrix_fd, df, field)
    if pp.derL:
        _,_,_,matrix_fd = occupation_solver.apply_centraldiff_matrix_L(matrix_fd, df, field)
    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    if pp.verboseError:
        b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
        error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
        print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,False)
    l_df = df.loc[l_inds]
    b = np.zeros(len(df))
    l_vel = utilities.mean_velocity(chi[l_inds],l_df)
    b[l_inds] = (-1) * ((l_df['vx [m/s]'] - l_vel) * f[l_inds])
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    print('Calculating preconditioner.')
    diagonal = np.diag(freq_matrix+matrix_sc * scmfac-matrix_fd)
    M = np.diag(np.reciprocal(diagonal))
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence,M=M)
    if pp.verboseError:
        b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
        error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
        print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
        print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
        print('Relative residual error is {:3E}'.format(error))
        print('GMRES convergence criteria: {:3E}'.format(criteria))
    else:
        error = 0
        print('Error not stored.')
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi
    return g_next, g_0,error, counter.niter


def correlation_3(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient Gamma-Gamma autocorrelation using the full
    finite difference matrix.

    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
        print('Not applying correction factor to scattering matrix.')
    print('Starting transient correlation 3 solver for {:.3E} V/m and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*2*np.pi*freq)  # Positive quantity
    _, _,_, _, matrix_fd = occupation_solver.apply_centraldiff_matrix(matrix_fd, df, field)
    if pp.derL:
        _,_,_,matrix_fd = occupation_solver.apply_centraldiff_matrix_L(matrix_fd, df, field)

    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    if pp.verboseError:
        b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
        error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
        print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,False)
    f_g = np.zeros(len(f), dtype=np.complex)
    f_l = np.zeros(len(f), dtype=np.complex)
    f_g[g_inds] = f[g_inds]
    f_l[l_inds] = f[l_inds]
    # Select "b" for the Gamma-Gamma autocorrelation.
    # b = -f_g*np.sum(f_l)/np.sum(f)
    b = -f_g
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    print('Calculating preconditioner.')
    diagonal = np.diag(freq_matrix+matrix_sc * scmfac-matrix_fd)
    M = np.diag(np.reciprocal(diagonal))
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence,M=M)
    if pp.verboseError:
        b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
        error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
        print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
        print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
        print('Relative residual error is {:3E}'.format(error))
    else:
        error = 0
        print('Error not stored.')
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi
    return g_next, g_0,error, counter.niter


def correlation_4(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient Gamma-Gamma autocorrelation using the full
    finite difference matrix.

    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
        print('Not applying correction factor to scattering matrix.')
    print('Starting transient correlation 4 solver for {:.3E} V/m and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*2*np.pi*freq)  # Positive quantity
    _, _,_, _, matrix_fd = occupation_solver.apply_centraldiff_matrix(matrix_fd, df, field)
    if pp.derL:
        _,_,_,matrix_fd = occupation_solver.apply_centraldiff_matrix_L(matrix_fd, df, field)

    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    if pp.verboseError:
        b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
        error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
        print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,False)
    f_g = np.zeros(len(f), dtype=np.complex)
    f_l = np.zeros(len(f), dtype=np.complex)
    f_g[g_inds] = f[g_inds]
    f_l[l_inds] = f[l_inds]
    # Select "b" for the Gamma-Gamma autocorrelation.
    # b = -f_g*np.sum(f_l)/np.sum(f)
    b = -f_l
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    print('Calculating preconditioner.')
    diagonal = np.diag(freq_matrix+matrix_sc * scmfac-matrix_fd)
    M = np.diag(np.reciprocal(diagonal))
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence,M=M)
    if pp.verboseError:
        b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
        error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
        print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
        print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
        print('Relative residual error is {:3E}'.format(error))
    else:
        error = 0
        print('Error not stored.')
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi
    return g_next, g_0,error, counter.niter


def write_correlations(fieldVector,df,freq):
    """Calls the GMRES solver hard coded for solving the effective BTE w/FDM for the Gamma-Gamma population
    autocorrelation for two-valleys and writes to file.
    Parameters:
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(pp.inputLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    utilities.check_matrix_properties(scm)
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        EField = fieldVector[i]
        chi = np.load(pp.outputLoc + 'Steady/' + 'chi_' + '3_' + "E_{:.1e}.npy".format(EField))
        fdm = np.memmap(pp.inputLoc + 'finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        g_inds, l_inds, x_inds = utilities.split_valleys(df, False)
        f0 = df['k_FD'].values
        f = chi + f0
        f_g = np.zeros(len(f), dtype=np.complex)
        f_l = np.zeros(len(f), dtype=np.complex)
        f_g[g_inds] = f[g_inds]
        f_l[l_inds] = f[l_inds]
        corr_1, corr_1_RTA,_, _ = correlation_1(chi, scm, fdm, df, EField, freq)
        corr_2, corr_2_RTA,_, _ = correlation_2(chi, scm, fdm, df, EField, freq)
        corr_3, corr_3_RTA,_, _ = correlation_3(chi, scm, fdm, df, EField, freq)
        corr_4, corr_4_RTA,_, _ = correlation_4(chi, scm, fdm, df, EField, freq)
        del fdm
        np.save(pp.outputLoc + 'Thermal/' + 'C1_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_1)
        np.save(pp.outputLoc + 'Thermal/' + 'C1_' + '1_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_1_RTA)

        np.save(pp.outputLoc + 'Thermal/' + 'C2_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_2)
        np.save(pp.outputLoc + 'Thermal/' + 'C2_' + '1_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_2_RTA)

        np.save(pp.outputLoc + 'Intervalley/' + 'C3_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_3)
        np.save(pp.outputLoc + 'Intervalley/' + 'C3_' + '1_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_3_RTA)

        np.save(pp.outputLoc + 'Intervalley/' + 'C4_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_4)
        np.save(pp.outputLoc + 'Intervalley/' + 'C4_' + '1_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),corr_4_RTA)

        print('Transient solution written to file for ' + "{:.1e} V/m and {:.1e} GHz".format(EField,freq))
        print('\n \n')


def thermal_density(EField,df,freq):
    g_inds, l_inds, x_inds = utilities.split_valleys(df, False)
    vx = df['vx [m/s]']

    corr_1 = np.load(pp.outputLoc + 'Thermal/' + 'C1_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_1_RTA = np.load(pp.outputLoc + 'Thermal/' + 'C1' + '1_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))

    corr_2 = np.load(pp.outputLoc + 'Thermal/' + 'C2_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_2_RTA = np.load(pp.outputLoc + 'Thermal/' + 'C2_' + '1_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))

    prefactor = 2*(c.e/c.Vuc)**2

    S_vv = np.real(prefactor*(np.sum(vx[g_inds]*corr_1[g_inds])+np.sum(vx[l_inds]*corr_2[l_inds])))
    S_vv_g = np.real(prefactor*np.sum(vx[g_inds]*corr_1[g_inds]))
    S_vv_l = np.real(prefactor*np.sum(vx[l_inds]*corr_2[l_inds]))

    S_vv_RTA = np.real(prefactor*(np.sum(vx[g_inds]*corr_1_RTA[g_inds])+np.sum(vx[l_inds]*corr_2_RTA[l_inds])))
    S_vv_g_RTA = np.real(prefactor*np.sum(vx[g_inds]*corr_1_RTA[g_inds]))
    S_vv_l_RTA = np.real(prefactor*np.sum(vx[l_inds]*corr_2_RTA[l_inds]))

    return S_vv, S_vv_g, S_vv_l, S_vv_RTA, S_vv_g_RTA, S_vv_l_RTA


def intervalley_density(chi, EField,df,freq):
    g_inds, l_inds, x_inds = utilities.split_valleys(df, False)
    Vd_g = utilities.mean_velocity(chi[g_inds], df.loc[g_inds])
    Vd_l = utilities.mean_velocity(chi[l_inds], df.loc[l_inds])
    f0 = df['k_FD'].values
    f = chi + f0

    corr_3 = np.load(pp.outputLoc + 'Intervalley/' + 'C3_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_3_RTA = np.load(pp.outputLoc + 'Intervalley/' + 'C3_' + '1_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))

    prefactor = 2*(c.e/c.Vuc)**2*(Vd_g-Vd_l)**2
    S_nn = np.real(prefactor*np.sum(corr_3[g_inds])*np.sum(f[l_inds])/np.sum(f))
    S_nn_RTA = np.real(prefactor * np.sum(corr_3_RTA[g_inds]) * np.sum(f[l_inds]) / np.sum(f))

    return S_nn, S_nn_RTA


def cross_density(chi, EField, df, freq):
    g_inds, l_inds, x_inds = utilities.split_valleys(df, False)
    Vd_g = utilities.mean_velocity(chi[g_inds], df.loc[g_inds])
    Vd_l = utilities.mean_velocity(chi[l_inds], df.loc[l_inds])
    vx = df['vx [m/s]']
    f0 = df['k_FD'].values
    f = chi + f0

    corr_3 = np.load(pp.outputLoc + 'Intervalley/' + 'C3_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_3_RTA = np.load(pp.outputLoc + 'Intervalley/' + 'C3_' + '1_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_4 = np.load(pp.outputLoc + 'Intervalley/' + 'C4_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    corr_4_RTA = np.load(pp.outputLoc + 'Intervalley/' + 'C4_' + '1_' + "f_{:.1e}_E_{:.1e}.npy".format(freq, EField))
    prefactor = (c.e / c.Vuc) ** 2
    S_vn = prefactor*np.real(-4*Vd_l*np.sum(corr_3[g_inds]*vx[g_inds])-4*(Vd_g-Vd_l)*np.sum(vx[g_inds]*corr_3[g_inds])*np.sum(f[l_inds])/np.sum(f)-4*(Vd_g-Vd_l)*np.sum(vx[l_inds]*corr_4[l_inds])*np.sum(f[g_inds])/np.sum(f))
    S_vn_RTA = prefactor*np.real(-4*Vd_l*np.sum(corr_3_RTA[g_inds]*vx[g_inds])-4*(Vd_g-Vd_l)*np.sum(vx[g_inds]*corr_3_RTA[g_inds])*np.sum(f[l_inds])/np.sum(f)-4*(Vd_g-Vd_l)*np.sum(vx[l_inds]*corr_4_RTA[l_inds])*np.sum(f[g_inds])/np.sum(f))

    return S_vn, S_vn_RTA


def plot_density(fieldVector,freq,df):
    S_vv_vector = []
    S_vv_g_vector = []
    S_vv_l_vector = []
    S_vv_RTA_vector = []
    S_vv_g_RTA_vector = []
    S_vv_l_RTA_vector = []
    S_nn_vector = []
    S_nn_RTA_vector = []
    S_vn_vector = []
    S_vn_RTA_vector = []

    for ee in fieldVector:
        chi = np.load(pp.outputLoc + 'Steady/' + 'chi_' + '3_' + "E_{:.1e}.npy".format(ee))
        S_vv, S_vv_g, S_vv_l, S_vv_RTA, S_vv_g_RTA, S_vv_l_RTA = thermal_density(ee,df,freq)
        S_nn, S_nn_RTA = intervalley_density(chi, ee, df, freq)
        S_vn, S_vn_RTA = cross_density(chi, ee, df, freq)
        S_vv_vector.append(S_vv)
        S_vv_g_vector.append(S_vv_g)
        S_vv_l_vector.append(S_vv_l)
        S_vv_RTA_vector.append(S_vv_RTA)
        S_vv_g_RTA_vector.append(S_vv_g_RTA)
        S_vv_l_RTA_vector.append(S_vv_l_RTA)
        S_nn_vector.append(S_nn)
        S_nn_RTA_vector.append(S_nn_RTA)
        S_vn_vector.append(S_vn)
        S_vn_RTA_vector.append(S_vn_RTA)

    kvcm = np.array(fieldVector) * 1e-5

    plt.figure()
    plt.plot(kvcm,S_vv_vector,label=r'$S_{vv}$')
    plt.plot(kvcm,S_nn_vector,label=r'$S_{nn}$')
    plt.plot(kvcm,S_vn_vector,label=r'$S_{vn}$')
    plt.plot(kvcm, np.array(S_vv_vector) + np.array(S_nn_vector) + np.array(S_vn_vector),label='Total')
    plt.legend()
    plt.xlabel('Field [kV/cm]')
    plt.ylabel('Spectral Density [A^2/m^6/Hz]')
    plt.title(pp.title_str+'_{:1e} GHz'.format(freq))

    plt.figure()
    plt.plot(kvcm,S_vv_vector)
    plt.plot(kvcm,S_vv_g_vector)
    plt.plot(kvcm,S_vv_l_vector)

    plt.figure()
    plt.plot(kvcm,S_nn_vector)
    plt.plot(kvcm,S_nn_RTA_vector)

    plt.figure()
    plt.plot(kvcm,S_vn_vector)
    plt.plot(kvcm,S_vn_RTA_vector)


    plt.figure()
    plt.plot(kvcm,S_vv_RTA_vector)
    plt.plot(kvcm,S_vv_g_RTA_vector)
    plt.plot(kvcm,S_vv_l_RTA_vector)

    # plt.figure()
    # # plt.figure(kvcm,S_vv_vector,label=r'$S_{vv}$')
    # # plt.figure(kvcm,S_nn_vector,label=r'$S_{nn}$')
    # # plt.figure(kvcm,S_vn_vector,label=r'$S_{vn}$')
    # plt.figure(kvcm,S_vv_vector)
    # plt.figure(kvcm,S_nn_vector)
    # plt.figure(kvcm,S_vn_vector)
    # plt.plot(kvcm,np.array(S_vv_vector)+np.array(S_nn_vector)-np.array(S_vn_vector))
    # plt.legend()
    # plt.xlabel('Field [kV/cm]')
    # plt.ylabel('Spectral Density [A^2/m^6/Hz]')


if __name__ == '__main__':
    # Create electron and phonon dataframes
    preprocessing.create_el_ph_dataframes(pp.inputLoc, overwrite=True)
    electron_df, phonon_df = utilities.load_el_ph_data(pp.inputLoc)
    electron_df = utilities.fermi_distribution(electron_df)

    fields = pp.fieldVector
    freq = pp.freqGHz

    write_correlations(fields, electron_df, freq)
    plot_density(fields, freq, electron_df)
    plt.show()