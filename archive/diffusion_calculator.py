import numpy as np
import pandas as pd
import time
import constants as c
import utilities
import problemparameters as pp
import matplotlib.pyplot as plt
import numpy.linalg
from scipy.sparse import linalg
import inspect
import matrix_solvers
import matrix_plotter
from scipy.spatial import distance


class gmres_counter(object):
    def __init__(self, disp=True):
        self._disp = disp
        self.niter = 0
    def __call__(self, rk=None):
        self.niter += 1
        if self._disp:
            print('iter %3i\trk = %s' % (self.niter, str(rk)))


def transient_state_full_drift_GMRES(matrix_sc, matrix_fd, kptdf, field, canonical=False, applyscmFac=False,
                                             convergence=1E-6):
    """Generalized minimal residual solver for calculating steady BTE solution in the form of Chi using the full finite
    difference matrix.
    Parameters:
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        kptdf (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        canonical (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        applyscmFac (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence (dbl): Specifies the percentage threshold for convergence.
    Returns:
        x_next (nparray): Numpy array containing the (hopefully) converged iterative solution as chi.
        x_0 (nparray): Numpy array containing the RTA solution as chi.
    """
    counter = gmres_counter()
    print('Starting steady_state_full_drift_iterative solver for {:.3E}'.format(field))
    if applyscmFac:
        scmfac = pp.scmVal
        print('Applying 2 Pi-squared factor.')
    else:
        scmfac = 1

    _, icinds_l,icinds_r, _, matrix_fd = matrix_solvers.apply_centraldiff_matrix(matrix_fd, kptdf, field)
    b = (-1)*c.e*field/c.kb_joule/pp.T * np.squeeze(kptdf['vx [m/s]'] * kptdf['k_FD']) * (1 - kptdf['k_FD'])
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    chi2psi = np.squeeze(kptdf['k_FD'] * (1 - kptdf['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    x_0 = b * invdiag
    freq = np.diag(np.ones(len(kptdf))*1j*10**9*-1*2*np.pi)

    # M2 = linalg.spilu(matrix_sc * scmfac - matrix_fd)
    # M_x = lambda x: M2.solve(x)
    # M = linalg.LinearOperator((len(kptdf), len(kptdf)), M_x)
    # print('Obtained preconditioner')
    # x_0 = np.load(pp.outputLoc + 'chi_3_gmres_{:.1e}.npy'.format(7.5e4))

    loopstart = time.time()
    x_next, criteria = linalg.gmres(freq+matrix_sc*scmfac-matrix_fd, b,x0=x_0,tol=1e-5,callback=counter)
    print('Convergence?')
    print(criteria)
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    b_check = np.dot(freq+matrix_sc*scmfac-matrix_fd,x_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Residual error is {:3E}'.format(error))

    if canonical:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in canonical linearization')
        x_next = x_next * chi2psi
        x_0 = x_0 * chi2psi
    return x_next, x_0, error, icinds_l, icinds_r


def write_fdm_GMRES(outLoc, inLoc, fieldVector, df, canonical2=False, applyscmFac2=False,
                               convergence2=1E-6):
    """Calls the GMRES solver hard coded for solving the BTE with full FDM and writes the chis to file.
    Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions.
        inLoc (str): String containing the location of the directory containing the scattering matrix, assumed simple
        linearization by default.
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        canonical2 (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        linearization, assumed simple by default (i.e. canonical=False).
        applyscmFac2 (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence2 (dbl): Specifies the percentage threshold for convergence.
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(inLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    error = []
    for i in range(len(fieldVector)):
        fdm = np.memmap(inLoc + '/finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        EField = fieldVector[i]
        x_next, _, temp_error, icinds_l, icinds_r = transient_state_full_drift_GMRES(scm, fdm, df, EField, canonical2, applyscmFac2, convergence2)
        error.append(temp_error)
        del fdm
        np.save(outLoc + 'chi_t_' + '3_gmres_' + "{:.1e}".format(EField), x_next)
        print('Solution written to file for ' + "{:.1e}".format(EField))
    np.save(outLoc + 'left_icinds', icinds_l)
    np.save(outLoc + 'right_icinds', icinds_r)

    plt.figure()
    plt.plot(fieldVector* 1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title(r'$Problem \, 5 \, Case \, 12: \, Initial \, guess = b* \tau^{-1}, \,tol = 1e-5$')
    plt.show()


def ng_ng_GMRES(chi, matrix_sc, matrix_fd, df, field,guess, simplelin=True, applyscmFac=False,get_X=True,plot_Valleys=False,
                                 convergence=1E-6):
    """Iterative solver for calculating effective BTE solution in the form of g_Chi using the full finite difference matrix.

    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        simplelin (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        applyscmFac (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence (dbl): Specifies the percentage threshold for convergence.
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """

    counter = gmres_counter()
    print('Starting eff_distr_g_iterative_solver solver for {:.3E}'.format(field))
    freq = np.diag(np.ones(len(df))*1j*10**9*-1*2*np.pi)
    if applyscmFac:
        scmfac = pp.scmVal
        print('Applying 2 Pi-squared factor.')
    else:
        scmfac = 1
    _, icinds_l,icinds_r, _, matrix_fd  = matrix_solvers.apply_centraldiff_matrix(matrix_fd, df, field)
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    b_chi_check = np.dot(freq+matrix_sc*scmfac-matrix_fd,chi)
    error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
    print('Residual error of chi is {:3E}'.format(error_chi))

    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,get_X,plot_Valleys)
    g_df = df.loc[g_inds]
    l_df = df.loc[l_inds]
    # g_vel = utilities.mean_velocity(chi[g_inds],g_df)
    # l_vel = utilities.mean_velocity(chi[l_inds],l_df)
    # print(r'Mean velocity in $\Gamma$ is {:3E}'.format(g_vel))
    # print('Mean velocity in L is {:3E}'.format(l_vel))
    ng,nl,nx,n = utilities.calc_popsplit(chi,df,get_X)

    f_g = np.zeros(len(f), dtype=np.complex)
    f_g[g_inds] = f[g_inds]
    chi_g = np.zeros(len(f), dtype=np.complex)
    chi_g[g_inds] = chi[g_inds]
    f0_g = np.zeros(len(f))
    f0_g[g_inds] = g_df['k_FD'].values

    # Case #1: b = -f_g
    b = -f_g

    # Case #2: b = -chi_g
    # b = -chi_g

    # Case #3: b = -f0_g
    # b = -f0_g

    # Case #4: b = -f_gl
    # b = np.zeros(len(df))
    # b[g_inds] = -f[g_inds]*nl/n
    # b[l_inds] = -f[l_inds]*ng/n

    # Case #5: b = -chi_gl
    # b = np.zeros(len(df))
    # b[g_inds] = -chi[g_inds]*nl/n
    # b[l_inds] = -chi[l_inds]*ng/n

    # Case #6: b = -f0_gl
    # b = np.zeros(len(df))
    # b[g_inds] = -f0[g_inds]*nl/n
    # b[l_inds] = -f0[l_inds]*ng/n

    # Case #7: b = -f
    # b = -f

    # Case #8: b = -chi
    # b = -chi

    # Case #9: b = -f0
    # b = -f0

    # Case #10: b = -(vx-vd_gl)f_gl
    # b = np.zeros(len(df))
    # g_vel = utilities.mean_velocity(chi[g_inds],g_df)
    # l_vel = utilities.mean_velocity(chi[l_inds],l_df)
    # print(r'Mean drift velocity in $\Gamma$ is {:3E}'.format(g_vel))
    # print('Mean drift velocity in L is {:3E}'.format(l_vel))
    # print(r'Mean thermal velocity in $\Gamma$ is {:3E}'.format(np.mean(np.abs(g_df['vx [m/s]'].values))))
    # print('Mean thermal velocity in L is {:3E}'.format(np.mean(np.abs(l_df['vx [m/s]'].values))))
    #
    # print(r'Population in $\Gamma$ is {:3E}'.format(ng))
    # print('Population in L is {:3E}'.format(nl))
    # print('Drift velocity is {:3E}'.format(utilities.drift_velocity(chi,df)))
    # b[g_inds] = (-1) * ((g_df['vx [m/s]'] - g_vel) * f[g_inds])
    # b[l_inds] = (-1) * ((l_df['vx [m/s]'] - l_vel) * f[l_inds])

    # Case #11: b = -df0/dkx*eE*vx (corresponds to steady Boltzmann solution)
    # b = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    # guess = np.load(pp.outputLoc + 'ng_ng_' + '3_gmres_' + "{:.1e}.npy".format(1.3e4))
    # b[g_inds] = b[g_inds]*nl/n
    # b[l_inds] = b[l_inds]*ng/n
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    loopstart = time.time()
    print('with callback')
    # M2 = linalg.spilu(matrix_sc * scmfac - matrix_fd)
    # M_x = lambda x: M2.solve(x)
    # M = linalg.LinearOperator((len(df), len(df)), M_x)
    # print('Obtained preconditioner')
    # g_next, criteria = linalg.gmres(matrix_sc * scmfac - matrix_fd, b*10e-6,x0=g_0,callback=counter,M=M)
    g_next, criteria = linalg.gmres(freq+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,tol=1e-5,atol=1e-30)
    # g_next, criteria = linalg.gmres(matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,tol=1e-8,atol=1e-30)
    b_check = np.dot(freq+matrix_sc*scmfac-matrix_fd,g_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))

    # g_next, criteria = linalg.lgmres(matrix_sc * scmfac - matrix_fd, b, x0=g_0, callback=counter)
    g_next = g_next*nl/n
    print('Convergence?')
    print(criteria)
    print(counter.niter)
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not simplelin:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi

    return g_next, g_0,error, counter.niter


def vd_vd_GMRES(chi, matrix_sc, matrix_fd, df, field, guess, simplelin=True, applyscmFac=False,get_X=True,plot_Valleys=False,
                                 convergence=1E-6):
    """Iterative solver for calculating effective BTE solution in the form of g_Chi using the full finite difference matrix.

    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        simplelin (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        applyscmFac (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence (dbl): Specifies the percentage threshold for convergence.
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """

    counter = gmres_counter()
    print('Starting eff_distr_g_iterative_solver solver for {:.3E}'.format(field))
    freq = np.diag(np.ones(len(df))*1j*10**9*-1*2*np.pi)
    if applyscmFac:
        scmfac = pp.scmVal
        print('Applying 2 Pi-squared factor.')
    else:
        scmfac = 1
    _, icinds_l,icinds_r, _, matrix_fd  = matrix_solvers.apply_centraldiff_matrix(matrix_fd, df, field)
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    b_chi_check = np.dot(freq+matrix_sc*scmfac-matrix_fd,chi)
    error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
    print('Residual error of chi is {:3E}'.format(error_chi))

    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,get_X,plot_Valleys)
    g_df = df.loc[g_inds]
    l_df = df.loc[l_inds]
    ng,nl,nx,n = utilities.calc_popsplit(chi,df,get_X)

    f_g = np.zeros(len(f), dtype=np.complex)
    f_g[g_inds] = f[g_inds]
    chi_g = np.zeros(len(f), dtype=np.complex)
    chi_g[g_inds] = chi[g_inds]
    f0_g = np.zeros(len(f))
    f0_g[g_inds] = g_df['k_FD'].values

    # Case #10: b = -(vx-vd_gl)f_gl
    b = np.zeros(len(df))
    g_vel = utilities.mean_velocity(chi[g_inds],g_df)
    l_vel = utilities.mean_velocity(chi[l_inds],l_df)
    print(r'Mean drift velocity in $\Gamma$ is {:3E}'.format(g_vel))
    print('Mean drift velocity in L is {:3E}'.format(l_vel))
    print(r'Mean thermal velocity in $\Gamma$ is {:3E}'.format(np.mean(np.abs(g_df['vx [m/s]'].values))))
    print('Mean thermal velocity in L is {:3E}'.format(np.mean(np.abs(l_df['vx [m/s]'].values))))
    print(r'Population in $\Gamma$ is {:3E}'.format(ng))
    print('Population in L is {:3E}'.format(nl))
    print('Drift velocity is {:3E}'.format(utilities.drift_velocity(chi,df)))
    b[g_inds] = (-1) * ((g_df['vx [m/s]'] - g_vel) * f[g_inds])
    b[l_inds] = (-1) * ((l_df['vx [m/s]'] - l_vel) * f[l_inds])

    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    loopstart = time.time()
    print('with callback')

    g_next, criteria = linalg.gmres(freq+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,tol=1e-5,atol=1e-30)
    b_check = np.dot(freq+matrix_sc*scmfac-matrix_fd,g_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))

    print('Convergence?')
    print(criteria)
    print(counter.niter)
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not simplelin:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi

    return g_next, g_0,error, counter.niter

def write_ng_ng_GMRES(outLoc, inLoc, fieldVector, df, simplelin2=True, applyscmFac2 = False,get_X=True,plot_Valleys=False,
                               convergence2=1E-6):
    """Calls the iterative solver hard coded for solving the effective BTE w/FDM and writes the chis to file.

    Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions and ready steady state chis.
        inLoc (str): String containing the location of the directory containing the scattering matrix, assumed simple
        linearization by default.
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        simplelin2 (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        linearization, assumed simple by default (i.e. canonical=False).
        applyscmFac2 (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence2 (dbl): Specifies the percentage threshold for convergence.

    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(inLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    # utilities.check_matrix_properties(scm)
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        EField = fieldVector[i]
        if i > 0:
            guess = np.load(pp.outputLoc + 'ng_ng_' + '3_gmres_' + "{:.1e}.npy".format(fieldVector[i-1]))
        else:
            guess = np.zeros(len(df))
        chi = np.load(outLoc + 'chi_t_3_gmres_{:.1e}.npy'.format(EField))
        fdm = np.memmap(inLoc + 'finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        g_next, g_3_johnson,temp_error, iterations = ng_ng_GMRES(chi, scm, fdm, df, EField,guess, simplelin2, applyscmFac2,get_X,plot_Valleys,convergence2)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(outLoc + 'ng_ng_' + '3_gmres_' + "{:.1e}".format(EField), g_next)
        print('Solution written to file for ' + "{:.1e}".format(EField))

    plt.figure()
    plt.plot(fieldVector* 1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title(r'$Problem \, 5 \, Case \, 12: \, Initial \, guess = b* \tau^{-1}, \,tol = 1e-5$')

    plt.figure()
    plt.plot(fieldVector* 1E-5,iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title(r'$Problem \, 5 \, Case \, 12: \, Initial \, guess = b* \tau^{-1}, \,tol = 1e-5$')
    plt.show()


def write_vd_vd_GMRES(outLoc, inLoc, fieldVector, df, simplelin2=True, applyscmFac2 = False,get_X=True,plot_Valleys=False,
                               convergence2=1E-6):
    """Calls the iterative solver hard coded for solving the effective BTE w/FDM and writes the chis to file.

    Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions and ready steady state chis.
        inLoc (str): String containing the location of the directory containing the scattering matrix, assumed simple
        linearization by default.
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        simplelin2 (bool): Boolean that specifies whether the scattering matrix is assumed simple or canonical
        linearization, assumed simple by default (i.e. canonical=False).
        applyscmFac2 (bool): Boolean that specifies whether or not to apply the 2*pi squared factor.
        convergence2 (dbl): Specifies the percentage threshold for convergence.

    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(inLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    # utilities.check_matrix_properties(scm)
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        EField = fieldVector[i]
        if i > 0:
            guess = np.load(pp.outputLoc + 'ng_ng_' + '3_gmres_' + "{:.1e}.npy".format(fieldVector[i-1]))
        else:
            guess = np.zeros(len(df))
        chi = np.load(outLoc + 'chi_t_3_gmres_{:.1e}.npy'.format(EField))
        fdm = np.memmap(inLoc + 'finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        g_next, g_3_johnson,temp_error, iterations = vd_vd_GMRES(chi, scm, fdm, df, EField,guess, simplelin2, applyscmFac2,get_X,plot_Valleys,convergence2)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(outLoc + 'vd_vd_' + '3_gmres_' + "{:.1e}".format(EField), g_next)
        print('Solution written to file for ' + "{:.1e}".format(EField))

    plt.figure()
    plt.plot(fieldVector* 1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title(r'$Problem \, 2 \, Case \, 11: \, Initial \, guess = b* \tau^{-1}, \,tol = 1e-5$')

    plt.figure()
    plt.plot(fieldVector* 1E-5,iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title(r'$Problem \, 2 \, Case \, 11: \, Initial \, guess = b* \tau^{-1}, \,tol = 1e-5$')
    plt.show()



def plot_vel_KDEs(outLoc, field, df):
    """Wrapper script for velocity_distribution_kde. Can do for the various solution schemes saved to file.
        Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions and ready steady state chis.
        field (dbl): the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.

    Returns:
        Nothing. Just the plots.
    """

    chi_3_i = np.load(outLoc + 'chi_3_gmres_{:.1e}.npy'.format(field))
    matrix_plotter.velocity_distribution_kde(chi_3_i, df, title='DC Chi {:.1e} V/m '.format(field) + pp.title_str)

    chi_2_i = np.load(outLoc + 'chi_t_3_gmres_{:.1e}.npy'.format(field))
    matrix_plotter.velocity_distribution_kde(np.real(chi_2_i), df,
                                      title=r'1 GHz Chi {:.1e} V/m '.format(field) + pp.title_str)
    plt.xlabel('x-Velocity [m/s]')
    plt.ylabel('Occupation [arb]')
    print('Relative residual {:E}'.format(np.linalg.norm(chi_2_i - chi_3_i) / np.linalg.norm(chi_3_i)))


def plot_AC_DC_error(outLoc, fieldVector):
    """Wrapper script for velocity_distribution_kde. Can do for the various solution schemes saved to file.
        Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions and ready steady state chis.
        field (dbl): the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.

    Returns:
        Nothing. Just the plots.
    """
    ac_dc_error = []
    ac_dc_cosine = []
    for ee in fields:
        chi_3_i = np.load(outLoc + 'chi_3_gmres_{:.1e}.npy'.format(ee))
        chi_2_i = np.load(outLoc + 'chi_t_3_gmres_{:.1e}.npy'.format(ee))
        ac_dc_error.append(np.linalg.norm(chi_2_i - chi_3_i) / np.linalg.norm(chi_3_i))
        ac_dc_cosine.append(distance.cosine(chi_2_i,chi_3_i)*-1)
        print('Relative residual is {:E}'.format(np.linalg.norm(chi_3_i-chi_2_i) / np.linalg.norm(chi_3_i)))
        print('Cosine similarity is {:E}'.format(ac_dc_cosine[-1]))


    plt.figure()
    plt.plot(fieldVector* 1E-5,ac_dc_error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('AC-DC Residual')
    plt.title(pp.title_str)

    plt.figure()
    plt.plot(fieldVector* 1E-5,ac_dc_cosine)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('AC-DC Cosine Similarity')
    plt.title(pp.title_str)


    plt.show()

if __name__ == '__main__':
    # Right now, the functions are hardcoded to look for a scattering matrix named 'scattering_matrix_5.87_simple.mmap'
    # in the in_Loc. This can be modified later to look for just scattering_matrix_simple, or the name can be passed as
    # an argument. I kind of lean towards the argument, because it would force you to change the name each time you ran
    # with a new scattering matrix, which is probably good so we don't mess up.

    # Point to inputs and outputs
    out_Loc = pp.outputLoc
    in_Loc = pp.inputLoc

    # Read problem parameters and specify electron DataFrame
    # utilities.load_electron_df(in_Loc)
    utilities.read_problem_params(in_Loc)
    electron_df = pd.read_pickle(in_Loc + 'electron_df.pkl')
    electron_df = utilities.fermi_distribution(electron_df)
    applySCMFac = pp.scmBool
    simpleLin = pp.simpleBool
    # fields = np.array([1e2,1e3,1e4,2.5e4,5e4,7.5e4,1e5,2e5,3e5])
    # fields = np.array([1.5e4,2e4])
    # fields = np.array([1e2,1e3,1e4,1.1e4,1.2e4,1.3e4,1.4e4,1.5e4])
    # fields = np.array([1e2,1e3,1e4,2.5e4,5e4,7.5e4,1e5])
    fields = np.array([1e2, 1e3, 1e4, 2e4, 3e4, 4e4, 5e4, 6e4, 7e4, 8e4, 9e4, 1e5,2e5])
    # fields = np.array([1e5])
    # write_fdm_GMRES(out_Loc, in_Loc, fields, electron_df, not simpleLin, applySCMFac, 1E-5)

    # write_ng_ng_GMRES(out_Loc, in_Loc, fields, electron_df, simpleLin, applySCMFac,False,False,1E-5)
    # write_vd_vd_GMRES(out_Loc, in_Loc, fields, electron_df, simpleLin, applySCMFac, False, False, 1E-5)
    # matrix_plotter.iv_diffusion(out_Loc, electron_df, fields)
    matrix_plotter.thermal_diffusion(out_Loc, electron_df, fields)

    # plot_vel_KDEs(out_Loc,fields[-2],electron_df)
    # plot_AC_DC_error(out_Loc,fields)
    plt.show()