import numpy as np
import pandas as pd
import time
import constants as c
import utilities
import problemparameters as pp
import matplotlib.pyplot as plt
import numpy.linalg
from scipy.sparse import linalg
import matrix_solvers
import preprocessing


class gmres_counter(object):
    """A class object that can be called during GMRES to give stepwise iterative residual."""
    def __init__(self, disp=True):
        self._disp = disp
        self.niter = 0
    def __call__(self, rk=None):
        self.niter += 1
        if self._disp:
            print('iter %3i\trk = %s' % (self.niter, str(rk)))


def transient_full_drift(matrix_sc, matrix_fd, kptdf, field, freq):
    """Generalized minimal residual solver for calculating transient BTE solution in the form of Chi using the full
    finite difference matrix.
    Parameters:
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        kptdf (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        x_next (nparray): Numpy array containing the (hopefully) converged iterative solution as chi.
        x_0 (nparray): Numpy array containing the RTA solution as chi.
        icinds_l (nparray): Numpy array containing the left side indices where the initial condition is applied.
        icinds_r (nparray): Numpy array containing the right side indices where the initial condition is applied.
        counter.niter (dbl): Number of iterations to reach desired relative convergence
    """
    counter = gmres_counter()
    print('Starting transient BTE solver for {:.3E} and {:.3E} GHz'.format(field,freq))
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
    _, icinds_l,icinds_r, _, matrix_fd = matrix_solvers.apply_centraldiff_matrix(matrix_fd, kptdf, field)

    loopstart = time.time()
    b = (-1)*c.e*field/c.kb_joule/pp.T * np.squeeze(kptdf['vx [m/s]'] * kptdf['k_FD']) * (1 - kptdf['k_FD'])
    chi2psi = np.squeeze(kptdf['k_FD'] * (1 - kptdf['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    x_0 = b * invdiag
    freq_matrix = np.diag(np.ones(len(kptdf))*1j*10**9*-1*2*np.pi*freq)
    x_next, criteria = linalg.gmres(freq_matrix+matrix_sc*scmfac-matrix_fd, b,x0=x_0,tol=pp.relConvergence,callback=counter,
                                    atol=pp.absConvergence)
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    # The following step is the calculation of the relative residual, which involves another MVP. This adds expense. If
    # we're confident in the convergence, we can omit this check to increase speed.
    b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,x_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in canonical linearization')
        x_next = x_next * chi2psi
        x_0 = x_0 * chi2psi
    return x_next, x_0, error, icinds_l, icinds_r, counter.niter


def steady_full_drift(matrix_sc, matrix_fd, kptdf, field):
    """Generalized minimal residual solver for calculating transient BTE solution in the form of Chi using the full
    finite difference matrix.
    Parameters:
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        kptdf (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
    Returns:
        x_next (nparray): Numpy array containing the (hopefully) converged iterative solution as chi.
        x_0 (nparray): Numpy array containing the RTA solution as chi.
        icinds_l (nparray): Numpy array containing the left side indices where the initial condition is applied.
        icinds_r (nparray): Numpy array containing the right side indices where the initial condition is applied.
        counter.niter (dbl): Number of iterations to reach desired relative convergence
    """
    counter = gmres_counter()
    print('Starting steady BTE solver for {:.3E}'.format(field))
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
    _, icinds_l,icinds_r, _, matrix_fd = matrix_solvers.apply_centraldiff_matrix(matrix_fd, kptdf, field)

    loopstart = time.time()
    b = (-1)*c.e*field/c.kb_joule/pp.T * np.squeeze(kptdf['vx [m/s]'] * kptdf['k_FD']) * (1 - kptdf['k_FD'])
    chi2psi = np.squeeze(kptdf['k_FD'] * (1 - kptdf['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    x_0 = b * invdiag
    x_next, criteria = linalg.gmres(matrix_sc*scmfac-matrix_fd, b,x0=x_0,tol=pp.relConvergence,callback=counter,
                                    atol=pp.absConvergence)
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    # The following step is the calculation of the relative residual, which involves another MVP. This adds expense. If
    # we're confident in the convergence, we can omit this check to increase speed.
    b_check = np.dot(matrix_sc*scmfac-matrix_fd,x_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in canonical linearization')
        x_next = x_next * chi2psi
        x_0 = x_0 * chi2psi
    return x_next, x_0, error, icinds_l, icinds_r, counter.niter


def write_steady(fieldVector, df):
    """Calls the GMRES solver hard coded for solving the BTE with full FDM and writes the chis to file.
    Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions.
        inLoc (str): String containing the location of the directory containing the scattering matrix, assumed simple
        linearization by default.
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField_freq. #1 corresponds to RTA, #2 corresponds to
        low-field, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(pp.inputLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        fdm = np.memmap(pp.inputLoc + '/finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        EField = fieldVector[i]
        x_next, _, temp_error, icinds_l, icinds_r, iterations = steady_full_drift(scm, fdm, df, EField)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(pp.outputLoc + 'Steady/' + 'chi_' + '3_' + "E_{:.1e}".format(EField), x_next)
        print('Steady solution written to file for ' + "{:.1e} V/m ".format(EField))
        print('\n \n')
    np.save(pp.outputLoc + 'left_icinds', icinds_l)
    np.save(pp.outputLoc + 'right_icinds', icinds_r)

    plt.figure()
    plt.plot(fieldVector*1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title('Steady Occupation' + pp.title_str)

    plt.figure()
    plt.plot(fieldVector*1E-5, iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title('Steady Occupation' + pp.title_str)
    plt.show()


def write_transient(fieldVector, df, freq):
    """Calls the GMRES solver hard coded for solving the BTE with full FDM and writes the chis to file.
    Parameters:
        outLoc (str): String containing the location of the directory to write the chi solutions.
        inLoc (str): String containing the location of the directory containing the scattering matrix, assumed simple
        linearization by default.
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField_freq. #1 corresponds to RTA, #2 corresponds to
        low-field, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(pp.inputLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    error = []
    iteration_count =[]
    for i in range(len(fieldVector)):
        fdm = np.memmap(pp.inputLoc + '/finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        EField = fieldVector[i]
        x_next, _, temp_error, icinds_l, icinds_r, iterations = transient_full_drift(scm, fdm, df, EField, freq)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(pp.outputLoc + 'Transient/' + 'chi_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField), x_next)
        print('Transient solution written to file for ' + "{:.1e} V/m and {:.1e} GHz".format(EField,freq))
        print('\n \n')
    np.save(pp.outputLoc + 'left_icinds', icinds_l)
    np.save(pp.outputLoc + 'right_icinds', icinds_r)

    plt.figure()
    plt.plot(fieldVector*1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title('Occupation {:.1e} GHz'.format(freq) + pp.title_str)

    plt.figure()
    plt.plot(fieldVector*1E-5, iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title('Occupation {:.1e} GHz'.format(freq) + pp.title_str)
    plt.show()


def ng_ng(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient Gamma-Gamma autocorrelation using the full
    finite difference matrix.

    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
    print('Starting transient Gamma-Gamma population autocorrelation solver for {:.3E} V/m and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*-1*2*np.pi*freq)
    _, icinds_l,icinds_r, _, matrix_fd = matrix_solvers.apply_centraldiff_matrix(matrix_fd, df, field)
    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
    error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
    print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,pp.getX,False)
    ng,nl,nx,n = utilities.calc_popsplit(chi,df,pp.getX)
    f_g = np.zeros(len(f), dtype=np.complex)
    f_g[g_inds] = f[g_inds]
    # Select "b" for the Gamma-Gamma autocorrelation
    b = -f_g
    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    print('with callback')
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence)
    b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))
    g_next = g_next*nl/n # Adjust the g_next to account for the population fraction
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi

    return g_next, g_0,error, counter.niter


def vd_vd(chi, matrix_sc, matrix_fd, df, field, freq):
    """Generalized minimal residual solver for calculating transient vd-vd autocorrelation using the full
    finite difference matrix.
    Parameters:
        chi (nparray): Solution for the steady distribution function in chi form.
        matrix_sc (memmap): Scattering matrix in simple linearization by default..
        matrix_fd (memmap): Finite difference matrix, generated by apply_centraldiff_matrix.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        field (dbl): Value of the electric field in V/m.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        g_next (nparray): Numpy array containing the (hopefully) converged iterative solution as g_chi.
        g_0 (nparray): Numpy array containing the RTA solution as g0_chi.
    """
    counter = gmres_counter()
    print('Starting transient vd-vd population autocorrelation solver for {:.3E} and {:E} GHz'.format(field,freq))
    freq_matrix = np.diag(np.ones(len(df))*1j*10**9*-1*2*np.pi*freq)
    if pp.scmBool:
        scmfac = pp.scmVal
        print('Applying correction factor to the scattering matrix.')
    else:
        scmfac = 1
    _, icinds_l,icinds_r, _, matrix_fd  = matrix_solvers.apply_centraldiff_matrix(matrix_fd, df, field)
    loopstart = time.time()
    # Will only be able to run if you have a precalculated chi stored on file
    b_chi = (-1) * c.e * field / c.kb_joule / pp.T * np.squeeze(df['vx [m/s]'] * df['k_FD']) * (1 - df['k_FD'])
    b_chi_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,chi)
    error_chi = np.linalg.norm(b_chi_check - b_chi)/np.linalg.norm(b_chi)
    print('Residual error of chi is {:3E}'.format(error_chi))
    f0 = df['k_FD'].values
    f = chi + f0
    g_inds, l_inds, x_inds = utilities.split_valleys(df,pp.getX,False)
    g_df = df.loc[g_inds]
    l_df = df.loc[l_inds]
    ng,nl,nx,n = utilities.calc_popsplit(chi,df,pp.getX)
    # Case #10: b = -(vx-vd_gl)f_gl
    b = np.zeros(len(df))
    g_vel = utilities.mean_velocity(chi[g_inds],g_df)
    l_vel = utilities.mean_velocity(chi[l_inds],l_df)
    print('Mean drift velocity in Gamma is {:3E}'.format(g_vel))
    print('Mean drift velocity in L is {:3E}'.format(l_vel))
    print('Mean thermal velocity in Gamma is {:3E}'.format(np.mean(np.abs(g_df['vx [m/s]'].values))))
    print('Mean thermal velocity in L is {:3E}'.format(np.mean(np.abs(l_df['vx [m/s]'].values))))
    print('Population in Gamma is {:3E}'.format(ng))
    print('Population in L is {:3E}'.format(nl))
    print('Drift velocity is {:3E}'.format(utilities.drift_velocity(chi,df)))
    b[g_inds] = (-1) * ((g_df['vx [m/s]'] - g_vel) * f[g_inds])
    b[l_inds] = (-1) * ((l_df['vx [m/s]'] - l_vel) * f[l_inds])

    # chi2psi is used to give the finite difference matrix the right factors in front since substitution made
    psi2chi = np.squeeze(df['k_FD'] * (1 - df['k_FD']))
    invdiag = (np.diag(matrix_sc) * scmfac) ** (-1)
    g_0 = b * invdiag
    g_next, criteria = linalg.gmres(freq_matrix+matrix_sc * scmfac-matrix_fd, b,x0=g_0,callback=counter,
                                    tol=pp.relConvergence, atol=pp.absConvergence)
    b_check = np.dot(freq_matrix+matrix_sc*scmfac-matrix_fd,g_next)
    error = np.linalg.norm(b_check - b)/np.linalg.norm(b)
    print('Norm of b is {:3E}'.format(np.linalg.norm(b)))
    print('Absolute residual error is {:3E}'.format(np.linalg.norm(b_check-b)))
    print('Relative residual error is {:3E}'.format(error))
    print('GMRES convergence criteria: {:3E}'.format(criteria))
    loopend = time.time()
    print('Convergence took {:.2f}s'.format(loopend - loopstart))
    if not pp.simpleBool:
        # Return chi in all cases so there's not confusion in plotting
        print('Converting psi to chi since matrix in simple linearization')
        g_next = g_next * psi2chi
        g_0 = g_0 * psi2chi
    return g_next, g_0,error, counter.niter


def write_ng_ng(fieldVector,df,freq):
    """Calls the GMRES solver hard coded for solving the effective BTE w/FDM for the Gamma-Gamma population
    autocorrelation for two-valleys and writes to file.
    Parameters:
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(pp.inputLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    # utilities.check_matrix_properties(scm)
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        EField = fieldVector[i]
        chi = np.load(pp.outputLoc + 'Transient/' + 'chi_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq,EField))
        fdm = np.memmap(pp.inputLoc + 'finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        g_next, g_3_johnson,temp_error, iterations = ng_ng(chi, scm, fdm, df, EField, freq)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(pp.outputLoc + 'Intervalley/' + 'ng_ng_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),g_next)
        print('Transient solution written to file for ' + "{:.1e} V/m and {:.1e} GHz".format(EField,freq))
        print('\n \n')
    plt.figure()
    plt.plot(fieldVector*1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title('ng_ng {:.1e} GHz'.format(freq) + pp.title_str)

    plt.figure()
    plt.plot(fieldVector*1E-5,iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title('ng_ng {:.1e} GHz'.format(freq) + pp.title_str)


def write_vd_vd(fieldVector,df,freq):
    """Calls the GMRES solver hard coded for solving the effective BTE w/FDM for the Gamma-Gamma population
    autocorrelation for two-valleys and writes to file.
    Parameters:
        fieldVector (nparray): Vector containing the values of the electric field to be evaluated in V/m.
        df (dataframe): Electron DataFrame indexed by kpt containing the energy associated with each state in eV.
        freq (dbl): Frequency in GHz to be used for the transient solution
    Returns:
        None. Just writes the chi solutions to file. chi_#_EField. #1 corresponds to low-field RTA, #2 corresponds to
        low-field iterative, #3 corresponds to full finite-difference iterative.
    """
    nkpts = len(np.unique(df['k_inds']))
    scm = np.memmap(pp.inputLoc + pp.scmName, dtype='float64', mode='r', shape=(nkpts, nkpts))
    # utilities.check_matrix_properties(scm)
    error = []
    iteration_count = []
    for i in range(len(fieldVector)):
        EField = fieldVector[i]
        chi = np.load(pp.outputLoc + 'Transient/' + 'chi_' + '3_' + "f_{:.1e}_E_{:.1e}.npy".format(freq,EField))
        fdm = np.memmap(pp.inputLoc + 'finite_difference_matrix.mmap', dtype='float64', mode='w+', shape=(nkpts, nkpts))
        g_next, g_3_johnson,temp_error, iterations = vd_vd(chi, scm, fdm, df, EField,freq)
        error.append(temp_error)
        iteration_count.append(iterations)
        del fdm
        np.save(pp.outputLoc + 'Thermal/' + 'vd_vd_' + '3_' + "f_{:.1e}_E_{:.1e}".format(freq,EField),g_next)
        print('Transient solution written to file for ' + "{:.1e} V/m and {:.1e} GHz".format(EField,freq))
        print('\n \n')

    plt.figure()
    plt.plot(fieldVector*1E-5,error)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel(r'$|Ax_{f}-b|/|b|$')
    plt.title('vd_vd {:.1e} GHz'.format(freq) + pp.title_str)

    plt.figure()
    plt.plot(fieldVector*1E-5,iteration_count)
    plt.xlabel('EField (kV/cm)')
    plt.ylabel('Iterations to convergence')
    plt.title('vd_vd {:.1e} GHz'.format(freq) + pp.title_str)


if __name__ == '__main__':
    # Create electron and phonon dataframes
    # preprocessing.create_el_ph_dataframes(pp.inputLoc, overwrite=True)
    electron_df, phonon_df = utilities.load_el_ph_data(pp.inputLoc)
    electron_df = utilities.fermi_distribution(electron_df)

    # fields = pp.fieldVector
    freq = pp.freqGHz


    # write_transient(fields, electron_df, freq)
    # write_steady(fields, electron_df)

    # write_vd_vd(fields, electron_df, freq)
    fields = np.array([5e4, 6e4, 7e4, 8e4, 9e4, 1e5, 2e5])
    write_ng_ng(fields, electron_df, freq)

    plt.show()